,	
	{
	"model": "Principal.Apuesta",
	"pk": 1,
	"fields": {"titulo": 'Test Apuesta', "user":1,"opciones": "gana,empate,pierde", "descripcion":'Apuesta de prueba', "categoria":1,"fecha_inicio":"2012-09-06 00:00","fecha_fin":"2013-09-06 00:00", "estado":"a", "visibilidad"="pu", "tipo"="gpe"}
	}






class SampleClass(forms.Form):
def __init__(self, *args, **kwargs):
    super(SampleClass, self).__init__(*args, **kwargs)
    self.fields['name'].widget.attrs['class'] = 'my_class'





form = MyForm(instance = instance.obj)
form.fields['email'].widget.attrs = {'class':'here_class_name'}






def add(req):
    if req.method == 'POST':
        form = ArticleForm(req.POST)
        if form.is_valid():
            article = form.save(commit=False)
            article.author = req.user






""" class CategoriaForm(forms.Form):        
    slug = forms.SlugField()
    nombre = forms.CharField(max_length=250)
    def save(self):
        if self.is_valid():
            data=self.cleaned_data
            print data
            c = Categoria.objects.create(slug=data['slug'],nombre=data['nombre'])
            c.save()
        else:
            print 'buuuuuuuuuuuuu'"""
#tags = [tag.strip() for tag in tags.split(',') if tags]
            





@login_required
def edit(request, id=None, template_name='article_edit_template.html'):
    if id:
        article = get_object_or_404(Article, pk=id)
        if article.author != request.user:
            raise HttpResponseForbidden()
    else:
        article = Article(author=request.user)

    if request.POST:
        form = ArticleForm(request.POST, instance=article)
        if form.is_valid():
            form.save()

            # If the save was successful, redirect to another page
            redirect_url = reverse(article_save_success)
            return HttpResponseRedirect(redirect_url)

    else:
        form = ArticleForm(instance=article)

    return render_to_response(template_name, {
        'form': form,
    }, context_instance=RequestContext(request))













https://docs.djangoproject.com/en/dev/ref/models/instances/?from=olddo#id1

def clean(self):
    from django.core.exceptions import ValidationError
    # Don't allow draft entries to have a pub_date.
    if self.status == 'draft' and self.pub_date is not None:
        raise ValidationError('Draft entries may not have a publication date.')
    # Set the pub_date for published items if it hasn't been set already.
    if self.status == 'published' and self.pub_date is None:
        self.pub_date = datetime.date.today()





from django import forms
from django.core.validators import validate_email

class MultiEmailField(forms.Field):
    def to_python(self, value):
        "Normalize data to a list of strings."

        # Return an empty list if no input was given.
        if not value:
            return []
        return value.split(',')

    def validate(self, value):
        "Check if value consists only of valid emails."

        # Use the parent's handling of required fields, etc.
        super(MultiEmailField, self).validate(value)

        for email in value:
            validate_email(email)







class ContactForm(forms.Form):
    # Everything as before.
    ...

    def clean_recipients(self):
        data = self.cleaned_data['recipients']
        if "fred@example.com" not in data:
            raise forms.ValidationError("You have forgotten about Fred!")

        # Always return the cleaned data, whether you have changed it or
        # not.
        return data





class ContactForm(forms.Form):
    # Everything as before.
    ...

    def clean(self):
        cleaned_data = super(ContactForm, self).clean()
        cc_myself = cleaned_data.get("cc_myself")
        subject = cleaned_data.get("subject")

        if cc_myself and subject:
            # Only do something if both fields are valid so far.
            if "help" not in subject:
                raise forms.ValidationError("Did not send for 'help' in "
                        "the subject despite CC'ing yourself.")

        # Always return the full collection of cleaned data.
        return cleaned_data


class ContactForm(forms.Form):
    # Everything as before.
    ...

    def clean(self):
        cleaned_data = super(ContactForm, self).clean()
        cc_myself = cleaned_data.get("cc_myself")
        subject = cleaned_data.get("subject")

        if cc_myself and subject and "help" not in subject:
            # We know these are not in self._errors now (see discussion
            # below).
            msg = u"Must put 'help' in subject when cc'ing yourself."
            self._errors["cc_myself"] = self.error_class([msg])
            self._errors["subject"] = self.error_class([msg])

            # These fields are no longer valid. Remove them from the
            # cleaned data.
            del cleaned_data["cc_myself"]
            del cleaned_data["subject"]

        # Always return the full collection of cleaned data.
        return cleaned_data









from django.core.exceptions import ValidationError

def validate_even(value):
    if value % 2 != 0:
        raise ValidationError(u'%s is not an even number' % value)



from django import forms

#igual para modelos
class MyForm(forms.Form):
    even_field = forms.IntegerField(validators=[validate_even])















class BoutForm(forms.ModelForm):
    class Meta:
        model = Bout

    def clean(self):
        fighter_1 = self.cleaned_data.get('fighter_1')
        fighter_2 = self.cleaned_data.get('fighter_2')
        winner = self.cleaned_data.get('winner')  
        date = self.cleaned_data.get('date')

        if not (fighter_1 and fighter_2 and (fighter_1.id != fighter_2)):
            raise forms.ValidationError("Both fighters cannot be the same")

        if not (winner and (winner.id == fighter_1.id or winner.id == fighter_2.id)):
            raise forms.ValidationError("Winner is not in the fight")

        if not (date and date < datetime.today()):
            raise forms.ValidationError("Winner is not in the fight")

        return self.cleaned_data






https://docs.djangoproject.com/en/dev/ref/forms/widgets/#django.forms.SplitDateTimeWidget
comment = forms.CharField(
               widget=forms.TextInput(attrs={'size':'40'}))
comment .render('name', 'A name')




user = request.user
if user.is_authenticated():
    user_id=user.pk # pk means primary key

def question_submit(request):
    u = request.user
    if u.is_authenticated():
        if q.is_valid():
            f=q.save(commit=False)
            f.user=u
            f.save()









class MusicForm(forms.ModelForm):
    artist_id = forms.IntegerField(label="", widget=forms.HiddenInput(), required=False)
    artist = forms.CharField(required=False)
    # other fields ...

    class Meta:
        model = Music

    def clean_artist(self):
        if self.cleaned_data.get('artist') == '':
            artist = None
        else:
            artist_id = self.cleaned_data.get('artist_id') # this returns always None because artist_id is not in cleaned_fields (this seemed to work with previous django versions but not with current SVN version)
            if artist_id != None:
                artist = Artist.objects.get(id=artist_id)
            else:
                artist = None

    return artist

            return JsonResponse({'success': True})


sku = forms.CharField(widget = forms.TextInput(attrs={'readonly':'readonly'}))

http://stackoverflow.com/questions/4665719/add-fields-to-django-modelform-that-arent-in-the-model
http://stackoverflow.com/questions/38601/using-django-time-date-widgets-in-custom-form
def clean_fecha(self):
  if self.fecha >  datetime.now():
        raise ValidationError('Start date can\'t be in the future')
        
        
        
from django.utils import timezone
timezone.localtime(timezone.now())       
created = models.DateTimeField(editable=False,auto_now=False, auto_now_add=True)
http://stackoverflow.com/questions/10150301/model-has-no-attribute-committed








    
"""
class UserCreateForm(UserCreationForm):
    job_title = forms.CharField(max_length=100, required=True)
    age = forms.IntegerField(required=True)

    class Meta:
        model = User

    def save(self, commit=True):
        if not commit:
            raise NotImplementedError("Can't create User and UserProfile without database save")
        user = super(UserCreateForm, self).save(commit=True)
        user_profile = UserProfile(user=user, job_title=self.cleaned_data['job_title'], 
            age=self.cleaned_data['age'])
        user_profile.save()
        return user,user_profile"""
#name = forms.CharField(widget=forms.TextInput(attrs={'class':'special'}))
#    dia_fin = forms.DateField(widget=forms.DateInput(attrs={'class': 'datepicker'}))#attrs={'class': 'datepicker'}
#    hora_fin = forms.TimeField(widget=forms.TimeInput(attrs={'class': 'timepicker'}))#attrs={'class': 'datepicker'}

"""class ApuestaForm(ModelForm):
    #user=forms.IntegerField()
    #user=1
    ""
    def save(self, commit = True):
        if self.is_valid():
            data=self.cleaned_data
            a = Apuesta.objects.create(titulo=data['titulo'], opciones=data['opciones'], descripcion=data['descripcion'],
                               imagen=['image'], user=self.user, categoria=data['categoria'], fecha_inicio=datetime.now(), 
                               fecha_fin=data['fecha_fin'], estado='a', visibilidad='pu', tipo=data['tipo'], )
        return a.save()
    ""
    class Meta:
        model= Apuesta
        #fields=('fecha_inicio','fecha_fin')
        exclude = ('user','fecha_inicio','estado','visibilidad')
        #self.
        widgets = {
            'fecha_inicio': forms.DateTimeInput(attrs={'class': 'datepicker'}),
            'fecha_fin': forms.DateTimeInput(attrs={'class': 'datepicker'}),
        }

        #    if self.is_valid():
        #        data=self.cleaned_data
                
                #a = Categoria.save(titulo=data['titulo'], opciones=data['opciones'], descripcion=data['descripcion'],
                #                             imagen=['image'], user=user, categoria=data['categoria'], fecha_inicio=datetime.now(), 
                #                             fecha_fin=data['fecha_fin'], estado=data['estado'], visibilidad='pu', tipo=data['tipo'] )
                #a.save()

        #widgets = {
        #           'name': Textarea(attrs={'cols': 80, 'rows': 20}),
        #}
        #def __init__(self, *args, **kwargs):
        #    super(MyForm, self).__init__(*args, **kwargs)
        #    self.fields['fecha_inicio'].widget.attrs={'class':''}
"""
